// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"itamconnect/ent/match"
	"itamconnect/ent/menti"
	"itamconnect/ent/mentor"
	"itamconnect/ent/message"
	"itamconnect/ent/predicate"
	"itamconnect/ent/realexperience"
	"itamconnect/ent/user"
	"itamconnect/internal/domain/valueobject"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeMatch          = "Match"
	TypeMenti          = "Menti"
	TypeMentor         = "Mentor"
	TypeMessage        = "Message"
	TypeRealExperience = "RealExperience"
	TypeUser           = "User"
)

// MatchMutation represents an operation that mutates the Match nodes in the graph.
type MatchMutation struct {
	config
	op              Op
	typ             string
	id              *int
	status          *valueobject.MatchStatus
	created_at      *time.Time
	clearedFields   map[string]struct{}
	mentor          *int
	clearedmentor   bool
	menti           *int
	clearedmenti    bool
	messages        map[int]struct{}
	removedmessages map[int]struct{}
	clearedmessages bool
	done            bool
	oldValue        func(context.Context) (*Match, error)
	predicates      []predicate.Match
}

var _ ent.Mutation = (*MatchMutation)(nil)

// matchOption allows management of the mutation configuration using functional options.
type matchOption func(*MatchMutation)

// newMatchMutation creates new mutation for the Match entity.
func newMatchMutation(c config, op Op, opts ...matchOption) *MatchMutation {
	m := &MatchMutation{
		config:        c,
		op:            op,
		typ:           TypeMatch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMatchID sets the ID field of the mutation.
func withMatchID(id int) matchOption {
	return func(m *MatchMutation) {
		var (
			err   error
			once  sync.Once
			value *Match
		)
		m.oldValue = func(ctx context.Context) (*Match, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Match.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMatch sets the old Match of the mutation.
func withMatch(node *Match) matchOption {
	return func(m *MatchMutation) {
		m.oldValue = func(context.Context) (*Match, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MatchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MatchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MatchMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MatchMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Match.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *MatchMutation) SetStatus(vs valueobject.MatchStatus) {
	m.status = &vs
}

// Status returns the value of the "status" field in the mutation.
func (m *MatchMutation) Status() (r valueobject.MatchStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldStatus(ctx context.Context) (v valueobject.MatchStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MatchMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MatchMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MatchMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MatchMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetMentorID sets the "mentor_id" field.
func (m *MatchMutation) SetMentorID(i int) {
	m.mentor = &i
}

// MentorID returns the value of the "mentor_id" field in the mutation.
func (m *MatchMutation) MentorID() (r int, exists bool) {
	v := m.mentor
	if v == nil {
		return
	}
	return *v, true
}

// OldMentorID returns the old "mentor_id" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldMentorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMentorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMentorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMentorID: %w", err)
	}
	return oldValue.MentorID, nil
}

// ResetMentorID resets all changes to the "mentor_id" field.
func (m *MatchMutation) ResetMentorID() {
	m.mentor = nil
}

// SetMentiID sets the "menti_id" field.
func (m *MatchMutation) SetMentiID(i int) {
	m.menti = &i
}

// MentiID returns the value of the "menti_id" field in the mutation.
func (m *MatchMutation) MentiID() (r int, exists bool) {
	v := m.menti
	if v == nil {
		return
	}
	return *v, true
}

// OldMentiID returns the old "menti_id" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldMentiID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMentiID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMentiID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMentiID: %w", err)
	}
	return oldValue.MentiID, nil
}

// ResetMentiID resets all changes to the "menti_id" field.
func (m *MatchMutation) ResetMentiID() {
	m.menti = nil
}

// ClearMentor clears the "mentor" edge to the Mentor entity.
func (m *MatchMutation) ClearMentor() {
	m.clearedmentor = true
	m.clearedFields[match.FieldMentorID] = struct{}{}
}

// MentorCleared reports if the "mentor" edge to the Mentor entity was cleared.
func (m *MatchMutation) MentorCleared() bool {
	return m.clearedmentor
}

// MentorIDs returns the "mentor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MentorID instead. It exists only for internal usage by the builders.
func (m *MatchMutation) MentorIDs() (ids []int) {
	if id := m.mentor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMentor resets all changes to the "mentor" edge.
func (m *MatchMutation) ResetMentor() {
	m.mentor = nil
	m.clearedmentor = false
}

// ClearMenti clears the "menti" edge to the Menti entity.
func (m *MatchMutation) ClearMenti() {
	m.clearedmenti = true
	m.clearedFields[match.FieldMentiID] = struct{}{}
}

// MentiCleared reports if the "menti" edge to the Menti entity was cleared.
func (m *MatchMutation) MentiCleared() bool {
	return m.clearedmenti
}

// MentiIDs returns the "menti" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MentiID instead. It exists only for internal usage by the builders.
func (m *MatchMutation) MentiIDs() (ids []int) {
	if id := m.menti; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMenti resets all changes to the "menti" edge.
func (m *MatchMutation) ResetMenti() {
	m.menti = nil
	m.clearedmenti = false
}

// AddMessageIDs adds the "messages" edge to the Message entity by ids.
func (m *MatchMutation) AddMessageIDs(ids ...int) {
	if m.messages == nil {
		m.messages = make(map[int]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the Message entity.
func (m *MatchMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the Message entity was cleared.
func (m *MatchMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the Message entity by IDs.
func (m *MatchMutation) RemoveMessageIDs(ids ...int) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the Message entity.
func (m *MatchMutation) RemovedMessagesIDs() (ids []int) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *MatchMutation) MessagesIDs() (ids []int) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *MatchMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// Where appends a list predicates to the MatchMutation builder.
func (m *MatchMutation) Where(ps ...predicate.Match) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MatchMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MatchMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Match, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MatchMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MatchMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Match).
func (m *MatchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MatchMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.status != nil {
		fields = append(fields, match.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, match.FieldCreatedAt)
	}
	if m.mentor != nil {
		fields = append(fields, match.FieldMentorID)
	}
	if m.menti != nil {
		fields = append(fields, match.FieldMentiID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MatchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case match.FieldStatus:
		return m.Status()
	case match.FieldCreatedAt:
		return m.CreatedAt()
	case match.FieldMentorID:
		return m.MentorID()
	case match.FieldMentiID:
		return m.MentiID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MatchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case match.FieldStatus:
		return m.OldStatus(ctx)
	case match.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case match.FieldMentorID:
		return m.OldMentorID(ctx)
	case match.FieldMentiID:
		return m.OldMentiID(ctx)
	}
	return nil, fmt.Errorf("unknown Match field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MatchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case match.FieldStatus:
		v, ok := value.(valueobject.MatchStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case match.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case match.FieldMentorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMentorID(v)
		return nil
	case match.FieldMentiID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMentiID(v)
		return nil
	}
	return fmt.Errorf("unknown Match field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MatchMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MatchMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MatchMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Match numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MatchMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MatchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MatchMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Match nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MatchMutation) ResetField(name string) error {
	switch name {
	case match.FieldStatus:
		m.ResetStatus()
		return nil
	case match.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case match.FieldMentorID:
		m.ResetMentorID()
		return nil
	case match.FieldMentiID:
		m.ResetMentiID()
		return nil
	}
	return fmt.Errorf("unknown Match field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MatchMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.mentor != nil {
		edges = append(edges, match.EdgeMentor)
	}
	if m.menti != nil {
		edges = append(edges, match.EdgeMenti)
	}
	if m.messages != nil {
		edges = append(edges, match.EdgeMessages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MatchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case match.EdgeMentor:
		if id := m.mentor; id != nil {
			return []ent.Value{*id}
		}
	case match.EdgeMenti:
		if id := m.menti; id != nil {
			return []ent.Value{*id}
		}
	case match.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MatchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmessages != nil {
		edges = append(edges, match.EdgeMessages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MatchMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case match.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MatchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmentor {
		edges = append(edges, match.EdgeMentor)
	}
	if m.clearedmenti {
		edges = append(edges, match.EdgeMenti)
	}
	if m.clearedmessages {
		edges = append(edges, match.EdgeMessages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MatchMutation) EdgeCleared(name string) bool {
	switch name {
	case match.EdgeMentor:
		return m.clearedmentor
	case match.EdgeMenti:
		return m.clearedmenti
	case match.EdgeMessages:
		return m.clearedmessages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MatchMutation) ClearEdge(name string) error {
	switch name {
	case match.EdgeMentor:
		m.ClearMentor()
		return nil
	case match.EdgeMenti:
		m.ClearMenti()
		return nil
	}
	return fmt.Errorf("unknown Match unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MatchMutation) ResetEdge(name string) error {
	switch name {
	case match.EdgeMentor:
		m.ResetMentor()
		return nil
	case match.EdgeMenti:
		m.ResetMenti()
		return nil
	case match.EdgeMessages:
		m.ResetMessages()
		return nil
	}
	return fmt.Errorf("unknown Match edge %s", name)
}

// MentiMutation represents an operation that mutates the Menti nodes in the graph.
type MentiMutation struct {
	config
	op             Op
	typ            string
	id             *int
	clearedFields  map[string]struct{}
	user           map[int]struct{}
	removeduser    map[int]struct{}
	cleareduser    bool
	mentors        map[int]struct{}
	removedmentors map[int]struct{}
	clearedmentors bool
	matches        map[int]struct{}
	removedmatches map[int]struct{}
	clearedmatches bool
	done           bool
	oldValue       func(context.Context) (*Menti, error)
	predicates     []predicate.Menti
}

var _ ent.Mutation = (*MentiMutation)(nil)

// mentiOption allows management of the mutation configuration using functional options.
type mentiOption func(*MentiMutation)

// newMentiMutation creates new mutation for the Menti entity.
func newMentiMutation(c config, op Op, opts ...mentiOption) *MentiMutation {
	m := &MentiMutation{
		config:        c,
		op:            op,
		typ:           TypeMenti,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMentiID sets the ID field of the mutation.
func withMentiID(id int) mentiOption {
	return func(m *MentiMutation) {
		var (
			err   error
			once  sync.Once
			value *Menti
		)
		m.oldValue = func(ctx context.Context) (*Menti, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menti.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenti sets the old Menti of the mutation.
func withMenti(node *Menti) mentiOption {
	return func(m *MentiMutation) {
		m.oldValue = func(context.Context) (*Menti, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MentiMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MentiMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MentiMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MentiMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Menti.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *MentiMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *MentiMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MentiMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *MentiMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *MentiMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *MentiMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MentiMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddMentorIDs adds the "mentors" edge to the Mentor entity by ids.
func (m *MentiMutation) AddMentorIDs(ids ...int) {
	if m.mentors == nil {
		m.mentors = make(map[int]struct{})
	}
	for i := range ids {
		m.mentors[ids[i]] = struct{}{}
	}
}

// ClearMentors clears the "mentors" edge to the Mentor entity.
func (m *MentiMutation) ClearMentors() {
	m.clearedmentors = true
}

// MentorsCleared reports if the "mentors" edge to the Mentor entity was cleared.
func (m *MentiMutation) MentorsCleared() bool {
	return m.clearedmentors
}

// RemoveMentorIDs removes the "mentors" edge to the Mentor entity by IDs.
func (m *MentiMutation) RemoveMentorIDs(ids ...int) {
	if m.removedmentors == nil {
		m.removedmentors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.mentors, ids[i])
		m.removedmentors[ids[i]] = struct{}{}
	}
}

// RemovedMentors returns the removed IDs of the "mentors" edge to the Mentor entity.
func (m *MentiMutation) RemovedMentorsIDs() (ids []int) {
	for id := range m.removedmentors {
		ids = append(ids, id)
	}
	return
}

// MentorsIDs returns the "mentors" edge IDs in the mutation.
func (m *MentiMutation) MentorsIDs() (ids []int) {
	for id := range m.mentors {
		ids = append(ids, id)
	}
	return
}

// ResetMentors resets all changes to the "mentors" edge.
func (m *MentiMutation) ResetMentors() {
	m.mentors = nil
	m.clearedmentors = false
	m.removedmentors = nil
}

// AddMatchIDs adds the "matches" edge to the Match entity by ids.
func (m *MentiMutation) AddMatchIDs(ids ...int) {
	if m.matches == nil {
		m.matches = make(map[int]struct{})
	}
	for i := range ids {
		m.matches[ids[i]] = struct{}{}
	}
}

// ClearMatches clears the "matches" edge to the Match entity.
func (m *MentiMutation) ClearMatches() {
	m.clearedmatches = true
}

// MatchesCleared reports if the "matches" edge to the Match entity was cleared.
func (m *MentiMutation) MatchesCleared() bool {
	return m.clearedmatches
}

// RemoveMatchIDs removes the "matches" edge to the Match entity by IDs.
func (m *MentiMutation) RemoveMatchIDs(ids ...int) {
	if m.removedmatches == nil {
		m.removedmatches = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.matches, ids[i])
		m.removedmatches[ids[i]] = struct{}{}
	}
}

// RemovedMatches returns the removed IDs of the "matches" edge to the Match entity.
func (m *MentiMutation) RemovedMatchesIDs() (ids []int) {
	for id := range m.removedmatches {
		ids = append(ids, id)
	}
	return
}

// MatchesIDs returns the "matches" edge IDs in the mutation.
func (m *MentiMutation) MatchesIDs() (ids []int) {
	for id := range m.matches {
		ids = append(ids, id)
	}
	return
}

// ResetMatches resets all changes to the "matches" edge.
func (m *MentiMutation) ResetMatches() {
	m.matches = nil
	m.clearedmatches = false
	m.removedmatches = nil
}

// Where appends a list predicates to the MentiMutation builder.
func (m *MentiMutation) Where(ps ...predicate.Menti) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MentiMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MentiMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Menti, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MentiMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MentiMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Menti).
func (m *MentiMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MentiMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MentiMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MentiMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Menti field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MentiMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Menti field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MentiMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MentiMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MentiMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Menti numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MentiMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MentiMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MentiMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Menti nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MentiMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Menti field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MentiMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, menti.EdgeUser)
	}
	if m.mentors != nil {
		edges = append(edges, menti.EdgeMentors)
	}
	if m.matches != nil {
		edges = append(edges, menti.EdgeMatches)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MentiMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menti.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case menti.EdgeMentors:
		ids := make([]ent.Value, 0, len(m.mentors))
		for id := range m.mentors {
			ids = append(ids, id)
		}
		return ids
	case menti.EdgeMatches:
		ids := make([]ent.Value, 0, len(m.matches))
		for id := range m.matches {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MentiMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeduser != nil {
		edges = append(edges, menti.EdgeUser)
	}
	if m.removedmentors != nil {
		edges = append(edges, menti.EdgeMentors)
	}
	if m.removedmatches != nil {
		edges = append(edges, menti.EdgeMatches)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MentiMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menti.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case menti.EdgeMentors:
		ids := make([]ent.Value, 0, len(m.removedmentors))
		for id := range m.removedmentors {
			ids = append(ids, id)
		}
		return ids
	case menti.EdgeMatches:
		ids := make([]ent.Value, 0, len(m.removedmatches))
		for id := range m.removedmatches {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MentiMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, menti.EdgeUser)
	}
	if m.clearedmentors {
		edges = append(edges, menti.EdgeMentors)
	}
	if m.clearedmatches {
		edges = append(edges, menti.EdgeMatches)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MentiMutation) EdgeCleared(name string) bool {
	switch name {
	case menti.EdgeUser:
		return m.cleareduser
	case menti.EdgeMentors:
		return m.clearedmentors
	case menti.EdgeMatches:
		return m.clearedmatches
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MentiMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Menti unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MentiMutation) ResetEdge(name string) error {
	switch name {
	case menti.EdgeUser:
		m.ResetUser()
		return nil
	case menti.EdgeMentors:
		m.ResetMentors()
		return nil
	case menti.EdgeMatches:
		m.ResetMatches()
		return nil
	}
	return fmt.Errorf("unknown Menti edge %s", name)
}

// MentorMutation represents an operation that mutates the Mentor nodes in the graph.
type MentorMutation struct {
	config
	op             Op
	typ            string
	id             *int
	search_for     *string
	clearedFields  map[string]struct{}
	user           map[int]struct{}
	removeduser    map[int]struct{}
	cleareduser    bool
	mentis         map[int]struct{}
	removedmentis  map[int]struct{}
	clearedmentis  bool
	matches        map[int]struct{}
	removedmatches map[int]struct{}
	clearedmatches bool
	done           bool
	oldValue       func(context.Context) (*Mentor, error)
	predicates     []predicate.Mentor
}

var _ ent.Mutation = (*MentorMutation)(nil)

// mentorOption allows management of the mutation configuration using functional options.
type mentorOption func(*MentorMutation)

// newMentorMutation creates new mutation for the Mentor entity.
func newMentorMutation(c config, op Op, opts ...mentorOption) *MentorMutation {
	m := &MentorMutation{
		config:        c,
		op:            op,
		typ:           TypeMentor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMentorID sets the ID field of the mutation.
func withMentorID(id int) mentorOption {
	return func(m *MentorMutation) {
		var (
			err   error
			once  sync.Once
			value *Mentor
		)
		m.oldValue = func(ctx context.Context) (*Mentor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Mentor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMentor sets the old Mentor of the mutation.
func withMentor(node *Mentor) mentorOption {
	return func(m *MentorMutation) {
		m.oldValue = func(context.Context) (*Mentor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MentorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MentorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MentorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MentorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Mentor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSearchFor sets the "search_for" field.
func (m *MentorMutation) SetSearchFor(s string) {
	m.search_for = &s
}

// SearchFor returns the value of the "search_for" field in the mutation.
func (m *MentorMutation) SearchFor() (r string, exists bool) {
	v := m.search_for
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchFor returns the old "search_for" field's value of the Mentor entity.
// If the Mentor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorMutation) OldSearchFor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchFor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchFor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchFor: %w", err)
	}
	return oldValue.SearchFor, nil
}

// ResetSearchFor resets all changes to the "search_for" field.
func (m *MentorMutation) ResetSearchFor() {
	m.search_for = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *MentorMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *MentorMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MentorMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *MentorMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *MentorMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *MentorMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MentorMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddMentiIDs adds the "mentis" edge to the Menti entity by ids.
func (m *MentorMutation) AddMentiIDs(ids ...int) {
	if m.mentis == nil {
		m.mentis = make(map[int]struct{})
	}
	for i := range ids {
		m.mentis[ids[i]] = struct{}{}
	}
}

// ClearMentis clears the "mentis" edge to the Menti entity.
func (m *MentorMutation) ClearMentis() {
	m.clearedmentis = true
}

// MentisCleared reports if the "mentis" edge to the Menti entity was cleared.
func (m *MentorMutation) MentisCleared() bool {
	return m.clearedmentis
}

// RemoveMentiIDs removes the "mentis" edge to the Menti entity by IDs.
func (m *MentorMutation) RemoveMentiIDs(ids ...int) {
	if m.removedmentis == nil {
		m.removedmentis = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.mentis, ids[i])
		m.removedmentis[ids[i]] = struct{}{}
	}
}

// RemovedMentis returns the removed IDs of the "mentis" edge to the Menti entity.
func (m *MentorMutation) RemovedMentisIDs() (ids []int) {
	for id := range m.removedmentis {
		ids = append(ids, id)
	}
	return
}

// MentisIDs returns the "mentis" edge IDs in the mutation.
func (m *MentorMutation) MentisIDs() (ids []int) {
	for id := range m.mentis {
		ids = append(ids, id)
	}
	return
}

// ResetMentis resets all changes to the "mentis" edge.
func (m *MentorMutation) ResetMentis() {
	m.mentis = nil
	m.clearedmentis = false
	m.removedmentis = nil
}

// AddMatchIDs adds the "matches" edge to the Match entity by ids.
func (m *MentorMutation) AddMatchIDs(ids ...int) {
	if m.matches == nil {
		m.matches = make(map[int]struct{})
	}
	for i := range ids {
		m.matches[ids[i]] = struct{}{}
	}
}

// ClearMatches clears the "matches" edge to the Match entity.
func (m *MentorMutation) ClearMatches() {
	m.clearedmatches = true
}

// MatchesCleared reports if the "matches" edge to the Match entity was cleared.
func (m *MentorMutation) MatchesCleared() bool {
	return m.clearedmatches
}

// RemoveMatchIDs removes the "matches" edge to the Match entity by IDs.
func (m *MentorMutation) RemoveMatchIDs(ids ...int) {
	if m.removedmatches == nil {
		m.removedmatches = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.matches, ids[i])
		m.removedmatches[ids[i]] = struct{}{}
	}
}

// RemovedMatches returns the removed IDs of the "matches" edge to the Match entity.
func (m *MentorMutation) RemovedMatchesIDs() (ids []int) {
	for id := range m.removedmatches {
		ids = append(ids, id)
	}
	return
}

// MatchesIDs returns the "matches" edge IDs in the mutation.
func (m *MentorMutation) MatchesIDs() (ids []int) {
	for id := range m.matches {
		ids = append(ids, id)
	}
	return
}

// ResetMatches resets all changes to the "matches" edge.
func (m *MentorMutation) ResetMatches() {
	m.matches = nil
	m.clearedmatches = false
	m.removedmatches = nil
}

// Where appends a list predicates to the MentorMutation builder.
func (m *MentorMutation) Where(ps ...predicate.Mentor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MentorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MentorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Mentor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MentorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MentorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Mentor).
func (m *MentorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MentorMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.search_for != nil {
		fields = append(fields, mentor.FieldSearchFor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MentorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mentor.FieldSearchFor:
		return m.SearchFor()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MentorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mentor.FieldSearchFor:
		return m.OldSearchFor(ctx)
	}
	return nil, fmt.Errorf("unknown Mentor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MentorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mentor.FieldSearchFor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchFor(v)
		return nil
	}
	return fmt.Errorf("unknown Mentor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MentorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MentorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MentorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Mentor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MentorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MentorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MentorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Mentor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MentorMutation) ResetField(name string) error {
	switch name {
	case mentor.FieldSearchFor:
		m.ResetSearchFor()
		return nil
	}
	return fmt.Errorf("unknown Mentor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MentorMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, mentor.EdgeUser)
	}
	if m.mentis != nil {
		edges = append(edges, mentor.EdgeMentis)
	}
	if m.matches != nil {
		edges = append(edges, mentor.EdgeMatches)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MentorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mentor.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case mentor.EdgeMentis:
		ids := make([]ent.Value, 0, len(m.mentis))
		for id := range m.mentis {
			ids = append(ids, id)
		}
		return ids
	case mentor.EdgeMatches:
		ids := make([]ent.Value, 0, len(m.matches))
		for id := range m.matches {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MentorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeduser != nil {
		edges = append(edges, mentor.EdgeUser)
	}
	if m.removedmentis != nil {
		edges = append(edges, mentor.EdgeMentis)
	}
	if m.removedmatches != nil {
		edges = append(edges, mentor.EdgeMatches)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MentorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case mentor.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case mentor.EdgeMentis:
		ids := make([]ent.Value, 0, len(m.removedmentis))
		for id := range m.removedmentis {
			ids = append(ids, id)
		}
		return ids
	case mentor.EdgeMatches:
		ids := make([]ent.Value, 0, len(m.removedmatches))
		for id := range m.removedmatches {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MentorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, mentor.EdgeUser)
	}
	if m.clearedmentis {
		edges = append(edges, mentor.EdgeMentis)
	}
	if m.clearedmatches {
		edges = append(edges, mentor.EdgeMatches)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MentorMutation) EdgeCleared(name string) bool {
	switch name {
	case mentor.EdgeUser:
		return m.cleareduser
	case mentor.EdgeMentis:
		return m.clearedmentis
	case mentor.EdgeMatches:
		return m.clearedmatches
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MentorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Mentor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MentorMutation) ResetEdge(name string) error {
	switch name {
	case mentor.EdgeUser:
		m.ResetUser()
		return nil
	case mentor.EdgeMentis:
		m.ResetMentis()
		return nil
	case mentor.EdgeMatches:
		m.ResetMatches()
		return nil
	}
	return fmt.Errorf("unknown Mentor edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	text          *string
	clearedFields map[string]struct{}
	from          *int
	clearedfrom   bool
	match         *int
	clearedmatch  bool
	done          bool
	oldValue      func(context.Context) (*Message, error)
	predicates    []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id int) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetText sets the "text" field.
func (m *MessageMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *MessageMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *MessageMutation) ResetText() {
	m.text = nil
}

// SetFromID sets the "from" edge to the User entity by id.
func (m *MessageMutation) SetFromID(id int) {
	m.from = &id
}

// ClearFrom clears the "from" edge to the User entity.
func (m *MessageMutation) ClearFrom() {
	m.clearedfrom = true
}

// FromCleared reports if the "from" edge to the User entity was cleared.
func (m *MessageMutation) FromCleared() bool {
	return m.clearedfrom
}

// FromID returns the "from" edge ID in the mutation.
func (m *MessageMutation) FromID() (id int, exists bool) {
	if m.from != nil {
		return *m.from, true
	}
	return
}

// FromIDs returns the "from" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) FromIDs() (ids []int) {
	if id := m.from; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFrom resets all changes to the "from" edge.
func (m *MessageMutation) ResetFrom() {
	m.from = nil
	m.clearedfrom = false
}

// SetMatchID sets the "match" edge to the Match entity by id.
func (m *MessageMutation) SetMatchID(id int) {
	m.match = &id
}

// ClearMatch clears the "match" edge to the Match entity.
func (m *MessageMutation) ClearMatch() {
	m.clearedmatch = true
}

// MatchCleared reports if the "match" edge to the Match entity was cleared.
func (m *MessageMutation) MatchCleared() bool {
	return m.clearedmatch
}

// MatchID returns the "match" edge ID in the mutation.
func (m *MessageMutation) MatchID() (id int, exists bool) {
	if m.match != nil {
		return *m.match, true
	}
	return
}

// MatchIDs returns the "match" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MatchID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) MatchIDs() (ids []int) {
	if id := m.match; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMatch resets all changes to the "match" edge.
func (m *MessageMutation) ResetMatch() {
	m.match = nil
	m.clearedmatch = false
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Message, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, message.FieldCreatedAt)
	}
	if m.text != nil {
		fields = append(fields, message.FieldText)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldCreatedAt:
		return m.CreatedAt()
	case message.FieldText:
		return m.Text()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case message.FieldText:
		return m.OldText(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case message.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case message.FieldText:
		m.ResetText()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.from != nil {
		edges = append(edges, message.EdgeFrom)
	}
	if m.match != nil {
		edges = append(edges, message.EdgeMatch)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeFrom:
		if id := m.from; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeMatch:
		if id := m.match; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfrom {
		edges = append(edges, message.EdgeFrom)
	}
	if m.clearedmatch {
		edges = append(edges, message.EdgeMatch)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeFrom:
		return m.clearedfrom
	case message.EdgeMatch:
		return m.clearedmatch
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeFrom:
		m.ClearFrom()
		return nil
	case message.EdgeMatch:
		m.ClearMatch()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeFrom:
		m.ResetFrom()
		return nil
	case message.EdgeMatch:
		m.ResetMatch()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// RealExperienceMutation represents an operation that mutates the RealExperience nodes in the graph.
type RealExperienceMutation struct {
	config
	op            Op
	typ           string
	id            *int
	where         *string
	as            *string
	how           *string
	description   *string
	when_started  *time.Time
	when_ended    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*RealExperience, error)
	predicates    []predicate.RealExperience
}

var _ ent.Mutation = (*RealExperienceMutation)(nil)

// realexperienceOption allows management of the mutation configuration using functional options.
type realexperienceOption func(*RealExperienceMutation)

// newRealExperienceMutation creates new mutation for the RealExperience entity.
func newRealExperienceMutation(c config, op Op, opts ...realexperienceOption) *RealExperienceMutation {
	m := &RealExperienceMutation{
		config:        c,
		op:            op,
		typ:           TypeRealExperience,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRealExperienceID sets the ID field of the mutation.
func withRealExperienceID(id int) realexperienceOption {
	return func(m *RealExperienceMutation) {
		var (
			err   error
			once  sync.Once
			value *RealExperience
		)
		m.oldValue = func(ctx context.Context) (*RealExperience, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RealExperience.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRealExperience sets the old RealExperience of the mutation.
func withRealExperience(node *RealExperience) realexperienceOption {
	return func(m *RealExperienceMutation) {
		m.oldValue = func(context.Context) (*RealExperience, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RealExperienceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RealExperienceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RealExperienceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RealExperienceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RealExperience.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWhere sets the "where" field.
func (m *RealExperienceMutation) SetWhere(s string) {
	m.where = &s
}

// GetWhere returns the value of the "where" field in the mutation.
func (m *RealExperienceMutation) GetWhere() (r string, exists bool) {
	v := m.where
	if v == nil {
		return
	}
	return *v, true
}

// OldWhere returns the old "where" field's value of the RealExperience entity.
// If the RealExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RealExperienceMutation) OldWhere(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWhere is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWhere requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWhere: %w", err)
	}
	return oldValue.Where, nil
}

// ResetWhere resets all changes to the "where" field.
func (m *RealExperienceMutation) ResetWhere() {
	m.where = nil
}

// SetAs sets the "as" field.
func (m *RealExperienceMutation) SetAs(s string) {
	m.as = &s
}

// As returns the value of the "as" field in the mutation.
func (m *RealExperienceMutation) As() (r string, exists bool) {
	v := m.as
	if v == nil {
		return
	}
	return *v, true
}

// OldAs returns the old "as" field's value of the RealExperience entity.
// If the RealExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RealExperienceMutation) OldAs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAs: %w", err)
	}
	return oldValue.As, nil
}

// ResetAs resets all changes to the "as" field.
func (m *RealExperienceMutation) ResetAs() {
	m.as = nil
}

// SetHow sets the "how" field.
func (m *RealExperienceMutation) SetHow(s string) {
	m.how = &s
}

// How returns the value of the "how" field in the mutation.
func (m *RealExperienceMutation) How() (r string, exists bool) {
	v := m.how
	if v == nil {
		return
	}
	return *v, true
}

// OldHow returns the old "how" field's value of the RealExperience entity.
// If the RealExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RealExperienceMutation) OldHow(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHow: %w", err)
	}
	return oldValue.How, nil
}

// ResetHow resets all changes to the "how" field.
func (m *RealExperienceMutation) ResetHow() {
	m.how = nil
}

// SetDescription sets the "description" field.
func (m *RealExperienceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RealExperienceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the RealExperience entity.
// If the RealExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RealExperienceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RealExperienceMutation) ResetDescription() {
	m.description = nil
}

// SetWhenStarted sets the "when_started" field.
func (m *RealExperienceMutation) SetWhenStarted(t time.Time) {
	m.when_started = &t
}

// WhenStarted returns the value of the "when_started" field in the mutation.
func (m *RealExperienceMutation) WhenStarted() (r time.Time, exists bool) {
	v := m.when_started
	if v == nil {
		return
	}
	return *v, true
}

// OldWhenStarted returns the old "when_started" field's value of the RealExperience entity.
// If the RealExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RealExperienceMutation) OldWhenStarted(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWhenStarted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWhenStarted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWhenStarted: %w", err)
	}
	return oldValue.WhenStarted, nil
}

// ClearWhenStarted clears the value of the "when_started" field.
func (m *RealExperienceMutation) ClearWhenStarted() {
	m.when_started = nil
	m.clearedFields[realexperience.FieldWhenStarted] = struct{}{}
}

// WhenStartedCleared returns if the "when_started" field was cleared in this mutation.
func (m *RealExperienceMutation) WhenStartedCleared() bool {
	_, ok := m.clearedFields[realexperience.FieldWhenStarted]
	return ok
}

// ResetWhenStarted resets all changes to the "when_started" field.
func (m *RealExperienceMutation) ResetWhenStarted() {
	m.when_started = nil
	delete(m.clearedFields, realexperience.FieldWhenStarted)
}

// SetWhenEnded sets the "when_ended" field.
func (m *RealExperienceMutation) SetWhenEnded(t time.Time) {
	m.when_ended = &t
}

// WhenEnded returns the value of the "when_ended" field in the mutation.
func (m *RealExperienceMutation) WhenEnded() (r time.Time, exists bool) {
	v := m.when_ended
	if v == nil {
		return
	}
	return *v, true
}

// OldWhenEnded returns the old "when_ended" field's value of the RealExperience entity.
// If the RealExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RealExperienceMutation) OldWhenEnded(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWhenEnded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWhenEnded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWhenEnded: %w", err)
	}
	return oldValue.WhenEnded, nil
}

// ClearWhenEnded clears the value of the "when_ended" field.
func (m *RealExperienceMutation) ClearWhenEnded() {
	m.when_ended = nil
	m.clearedFields[realexperience.FieldWhenEnded] = struct{}{}
}

// WhenEndedCleared returns if the "when_ended" field was cleared in this mutation.
func (m *RealExperienceMutation) WhenEndedCleared() bool {
	_, ok := m.clearedFields[realexperience.FieldWhenEnded]
	return ok
}

// ResetWhenEnded resets all changes to the "when_ended" field.
func (m *RealExperienceMutation) ResetWhenEnded() {
	m.when_ended = nil
	delete(m.clearedFields, realexperience.FieldWhenEnded)
}

// Where appends a list predicates to the RealExperienceMutation builder.
func (m *RealExperienceMutation) Where(ps ...predicate.RealExperience) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RealExperienceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RealExperienceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RealExperience, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RealExperienceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RealExperienceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RealExperience).
func (m *RealExperienceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RealExperienceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.where != nil {
		fields = append(fields, realexperience.FieldWhere)
	}
	if m.as != nil {
		fields = append(fields, realexperience.FieldAs)
	}
	if m.how != nil {
		fields = append(fields, realexperience.FieldHow)
	}
	if m.description != nil {
		fields = append(fields, realexperience.FieldDescription)
	}
	if m.when_started != nil {
		fields = append(fields, realexperience.FieldWhenStarted)
	}
	if m.when_ended != nil {
		fields = append(fields, realexperience.FieldWhenEnded)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RealExperienceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case realexperience.FieldWhere:
		return m.GetWhere()
	case realexperience.FieldAs:
		return m.As()
	case realexperience.FieldHow:
		return m.How()
	case realexperience.FieldDescription:
		return m.Description()
	case realexperience.FieldWhenStarted:
		return m.WhenStarted()
	case realexperience.FieldWhenEnded:
		return m.WhenEnded()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RealExperienceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case realexperience.FieldWhere:
		return m.OldWhere(ctx)
	case realexperience.FieldAs:
		return m.OldAs(ctx)
	case realexperience.FieldHow:
		return m.OldHow(ctx)
	case realexperience.FieldDescription:
		return m.OldDescription(ctx)
	case realexperience.FieldWhenStarted:
		return m.OldWhenStarted(ctx)
	case realexperience.FieldWhenEnded:
		return m.OldWhenEnded(ctx)
	}
	return nil, fmt.Errorf("unknown RealExperience field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RealExperienceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case realexperience.FieldWhere:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWhere(v)
		return nil
	case realexperience.FieldAs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAs(v)
		return nil
	case realexperience.FieldHow:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHow(v)
		return nil
	case realexperience.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case realexperience.FieldWhenStarted:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWhenStarted(v)
		return nil
	case realexperience.FieldWhenEnded:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWhenEnded(v)
		return nil
	}
	return fmt.Errorf("unknown RealExperience field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RealExperienceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RealExperienceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RealExperienceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RealExperience numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RealExperienceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(realexperience.FieldWhenStarted) {
		fields = append(fields, realexperience.FieldWhenStarted)
	}
	if m.FieldCleared(realexperience.FieldWhenEnded) {
		fields = append(fields, realexperience.FieldWhenEnded)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RealExperienceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RealExperienceMutation) ClearField(name string) error {
	switch name {
	case realexperience.FieldWhenStarted:
		m.ClearWhenStarted()
		return nil
	case realexperience.FieldWhenEnded:
		m.ClearWhenEnded()
		return nil
	}
	return fmt.Errorf("unknown RealExperience nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RealExperienceMutation) ResetField(name string) error {
	switch name {
	case realexperience.FieldWhere:
		m.ResetWhere()
		return nil
	case realexperience.FieldAs:
		m.ResetAs()
		return nil
	case realexperience.FieldHow:
		m.ResetHow()
		return nil
	case realexperience.FieldDescription:
		m.ResetDescription()
		return nil
	case realexperience.FieldWhenStarted:
		m.ResetWhenStarted()
		return nil
	case realexperience.FieldWhenEnded:
		m.ResetWhenEnded()
		return nil
	}
	return fmt.Errorf("unknown RealExperience field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RealExperienceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RealExperienceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RealExperienceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RealExperienceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RealExperienceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RealExperienceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RealExperienceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RealExperience unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RealExperienceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RealExperience edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	login                   *string
	hashed_password         *string
	email                   *valueobject.Email
	bio                     *string
	education_info          *string
	phone                   *string
	telegram                *string
	other_contacts          *string
	skills                  *[]string
	appendskills            []string
	_type                   *valueobject.UserType
	clearedFields           map[string]struct{}
	real_experiences        map[int]struct{}
	removedreal_experiences map[int]struct{}
	clearedreal_experiences bool
	menti                   *int
	clearedmenti            bool
	mentor                  *int
	clearedmentor           bool
	done                    bool
	oldValue                func(context.Context) (*User, error)
	predicates              []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLogin sets the "login" field.
func (m *UserMutation) SetLogin(s string) {
	m.login = &s
}

// Login returns the value of the "login" field in the mutation.
func (m *UserMutation) Login() (r string, exists bool) {
	v := m.login
	if v == nil {
		return
	}
	return *v, true
}

// OldLogin returns the old "login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLogin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogin: %w", err)
	}
	return oldValue.Login, nil
}

// ResetLogin resets all changes to the "login" field.
func (m *UserMutation) ResetLogin() {
	m.login = nil
}

// SetHashedPassword sets the "hashed_password" field.
func (m *UserMutation) SetHashedPassword(s string) {
	m.hashed_password = &s
}

// HashedPassword returns the value of the "hashed_password" field in the mutation.
func (m *UserMutation) HashedPassword() (r string, exists bool) {
	v := m.hashed_password
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedPassword returns the old "hashed_password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHashedPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedPassword: %w", err)
	}
	return oldValue.HashedPassword, nil
}

// ResetHashedPassword resets all changes to the "hashed_password" field.
func (m *UserMutation) ResetHashedPassword() {
	m.hashed_password = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(v valueobject.Email) {
	m.email = &v
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r valueobject.Email, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v valueobject.Email, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetBio sets the "bio" field.
func (m *UserMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *UserMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ResetBio resets all changes to the "bio" field.
func (m *UserMutation) ResetBio() {
	m.bio = nil
}

// SetEducationInfo sets the "education_info" field.
func (m *UserMutation) SetEducationInfo(s string) {
	m.education_info = &s
}

// EducationInfo returns the value of the "education_info" field in the mutation.
func (m *UserMutation) EducationInfo() (r string, exists bool) {
	v := m.education_info
	if v == nil {
		return
	}
	return *v, true
}

// OldEducationInfo returns the old "education_info" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEducationInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEducationInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEducationInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducationInfo: %w", err)
	}
	return oldValue.EducationInfo, nil
}

// ResetEducationInfo resets all changes to the "education_info" field.
func (m *UserMutation) ResetEducationInfo() {
	m.education_info = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetTelegram sets the "telegram" field.
func (m *UserMutation) SetTelegram(s string) {
	m.telegram = &s
}

// Telegram returns the value of the "telegram" field in the mutation.
func (m *UserMutation) Telegram() (r string, exists bool) {
	v := m.telegram
	if v == nil {
		return
	}
	return *v, true
}

// OldTelegram returns the old "telegram" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTelegram(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelegram is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelegram requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelegram: %w", err)
	}
	return oldValue.Telegram, nil
}

// ClearTelegram clears the value of the "telegram" field.
func (m *UserMutation) ClearTelegram() {
	m.telegram = nil
	m.clearedFields[user.FieldTelegram] = struct{}{}
}

// TelegramCleared returns if the "telegram" field was cleared in this mutation.
func (m *UserMutation) TelegramCleared() bool {
	_, ok := m.clearedFields[user.FieldTelegram]
	return ok
}

// ResetTelegram resets all changes to the "telegram" field.
func (m *UserMutation) ResetTelegram() {
	m.telegram = nil
	delete(m.clearedFields, user.FieldTelegram)
}

// SetOtherContacts sets the "other_contacts" field.
func (m *UserMutation) SetOtherContacts(s string) {
	m.other_contacts = &s
}

// OtherContacts returns the value of the "other_contacts" field in the mutation.
func (m *UserMutation) OtherContacts() (r string, exists bool) {
	v := m.other_contacts
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherContacts returns the old "other_contacts" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOtherContacts(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherContacts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherContacts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherContacts: %w", err)
	}
	return oldValue.OtherContacts, nil
}

// ClearOtherContacts clears the value of the "other_contacts" field.
func (m *UserMutation) ClearOtherContacts() {
	m.other_contacts = nil
	m.clearedFields[user.FieldOtherContacts] = struct{}{}
}

// OtherContactsCleared returns if the "other_contacts" field was cleared in this mutation.
func (m *UserMutation) OtherContactsCleared() bool {
	_, ok := m.clearedFields[user.FieldOtherContacts]
	return ok
}

// ResetOtherContacts resets all changes to the "other_contacts" field.
func (m *UserMutation) ResetOtherContacts() {
	m.other_contacts = nil
	delete(m.clearedFields, user.FieldOtherContacts)
}

// SetSkills sets the "skills" field.
func (m *UserMutation) SetSkills(s []string) {
	m.skills = &s
	m.appendskills = nil
}

// Skills returns the value of the "skills" field in the mutation.
func (m *UserMutation) Skills() (r []string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSkills(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// AppendSkills adds s to the "skills" field.
func (m *UserMutation) AppendSkills(s []string) {
	m.appendskills = append(m.appendskills, s...)
}

// AppendedSkills returns the list of values that were appended to the "skills" field in this mutation.
func (m *UserMutation) AppendedSkills() ([]string, bool) {
	if len(m.appendskills) == 0 {
		return nil, false
	}
	return m.appendskills, true
}

// ResetSkills resets all changes to the "skills" field.
func (m *UserMutation) ResetSkills() {
	m.skills = nil
	m.appendskills = nil
}

// SetType sets the "type" field.
func (m *UserMutation) SetType(vt valueobject.UserType) {
	m._type = &vt
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserMutation) GetType() (r valueobject.UserType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldType(ctx context.Context) (v valueobject.UserType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *UserMutation) ResetType() {
	m._type = nil
}

// AddRealExperienceIDs adds the "real_experiences" edge to the RealExperience entity by ids.
func (m *UserMutation) AddRealExperienceIDs(ids ...int) {
	if m.real_experiences == nil {
		m.real_experiences = make(map[int]struct{})
	}
	for i := range ids {
		m.real_experiences[ids[i]] = struct{}{}
	}
}

// ClearRealExperiences clears the "real_experiences" edge to the RealExperience entity.
func (m *UserMutation) ClearRealExperiences() {
	m.clearedreal_experiences = true
}

// RealExperiencesCleared reports if the "real_experiences" edge to the RealExperience entity was cleared.
func (m *UserMutation) RealExperiencesCleared() bool {
	return m.clearedreal_experiences
}

// RemoveRealExperienceIDs removes the "real_experiences" edge to the RealExperience entity by IDs.
func (m *UserMutation) RemoveRealExperienceIDs(ids ...int) {
	if m.removedreal_experiences == nil {
		m.removedreal_experiences = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.real_experiences, ids[i])
		m.removedreal_experiences[ids[i]] = struct{}{}
	}
}

// RemovedRealExperiences returns the removed IDs of the "real_experiences" edge to the RealExperience entity.
func (m *UserMutation) RemovedRealExperiencesIDs() (ids []int) {
	for id := range m.removedreal_experiences {
		ids = append(ids, id)
	}
	return
}

// RealExperiencesIDs returns the "real_experiences" edge IDs in the mutation.
func (m *UserMutation) RealExperiencesIDs() (ids []int) {
	for id := range m.real_experiences {
		ids = append(ids, id)
	}
	return
}

// ResetRealExperiences resets all changes to the "real_experiences" edge.
func (m *UserMutation) ResetRealExperiences() {
	m.real_experiences = nil
	m.clearedreal_experiences = false
	m.removedreal_experiences = nil
}

// SetMentiID sets the "menti" edge to the Menti entity by id.
func (m *UserMutation) SetMentiID(id int) {
	m.menti = &id
}

// ClearMenti clears the "menti" edge to the Menti entity.
func (m *UserMutation) ClearMenti() {
	m.clearedmenti = true
}

// MentiCleared reports if the "menti" edge to the Menti entity was cleared.
func (m *UserMutation) MentiCleared() bool {
	return m.clearedmenti
}

// MentiID returns the "menti" edge ID in the mutation.
func (m *UserMutation) MentiID() (id int, exists bool) {
	if m.menti != nil {
		return *m.menti, true
	}
	return
}

// MentiIDs returns the "menti" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MentiID instead. It exists only for internal usage by the builders.
func (m *UserMutation) MentiIDs() (ids []int) {
	if id := m.menti; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMenti resets all changes to the "menti" edge.
func (m *UserMutation) ResetMenti() {
	m.menti = nil
	m.clearedmenti = false
}

// SetMentorID sets the "mentor" edge to the Mentor entity by id.
func (m *UserMutation) SetMentorID(id int) {
	m.mentor = &id
}

// ClearMentor clears the "mentor" edge to the Mentor entity.
func (m *UserMutation) ClearMentor() {
	m.clearedmentor = true
}

// MentorCleared reports if the "mentor" edge to the Mentor entity was cleared.
func (m *UserMutation) MentorCleared() bool {
	return m.clearedmentor
}

// MentorID returns the "mentor" edge ID in the mutation.
func (m *UserMutation) MentorID() (id int, exists bool) {
	if m.mentor != nil {
		return *m.mentor, true
	}
	return
}

// MentorIDs returns the "mentor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MentorID instead. It exists only for internal usage by the builders.
func (m *UserMutation) MentorIDs() (ids []int) {
	if id := m.mentor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMentor resets all changes to the "mentor" edge.
func (m *UserMutation) ResetMentor() {
	m.mentor = nil
	m.clearedmentor = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.login != nil {
		fields = append(fields, user.FieldLogin)
	}
	if m.hashed_password != nil {
		fields = append(fields, user.FieldHashedPassword)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.bio != nil {
		fields = append(fields, user.FieldBio)
	}
	if m.education_info != nil {
		fields = append(fields, user.FieldEducationInfo)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.telegram != nil {
		fields = append(fields, user.FieldTelegram)
	}
	if m.other_contacts != nil {
		fields = append(fields, user.FieldOtherContacts)
	}
	if m.skills != nil {
		fields = append(fields, user.FieldSkills)
	}
	if m._type != nil {
		fields = append(fields, user.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldLogin:
		return m.Login()
	case user.FieldHashedPassword:
		return m.HashedPassword()
	case user.FieldEmail:
		return m.Email()
	case user.FieldBio:
		return m.Bio()
	case user.FieldEducationInfo:
		return m.EducationInfo()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldTelegram:
		return m.Telegram()
	case user.FieldOtherContacts:
		return m.OtherContacts()
	case user.FieldSkills:
		return m.Skills()
	case user.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldLogin:
		return m.OldLogin(ctx)
	case user.FieldHashedPassword:
		return m.OldHashedPassword(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldBio:
		return m.OldBio(ctx)
	case user.FieldEducationInfo:
		return m.OldEducationInfo(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldTelegram:
		return m.OldTelegram(ctx)
	case user.FieldOtherContacts:
		return m.OldOtherContacts(ctx)
	case user.FieldSkills:
		return m.OldSkills(ctx)
	case user.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldLogin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogin(v)
		return nil
	case user.FieldHashedPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedPassword(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(valueobject.Email)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case user.FieldEducationInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducationInfo(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldTelegram:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelegram(v)
		return nil
	case user.FieldOtherContacts:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherContacts(v)
		return nil
	case user.FieldSkills:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	case user.FieldType:
		v, ok := value.(valueobject.UserType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	if m.FieldCleared(user.FieldTelegram) {
		fields = append(fields, user.FieldTelegram)
	}
	if m.FieldCleared(user.FieldOtherContacts) {
		fields = append(fields, user.FieldOtherContacts)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	case user.FieldTelegram:
		m.ClearTelegram()
		return nil
	case user.FieldOtherContacts:
		m.ClearOtherContacts()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldLogin:
		m.ResetLogin()
		return nil
	case user.FieldHashedPassword:
		m.ResetHashedPassword()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldBio:
		m.ResetBio()
		return nil
	case user.FieldEducationInfo:
		m.ResetEducationInfo()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldTelegram:
		m.ResetTelegram()
		return nil
	case user.FieldOtherContacts:
		m.ResetOtherContacts()
		return nil
	case user.FieldSkills:
		m.ResetSkills()
		return nil
	case user.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.real_experiences != nil {
		edges = append(edges, user.EdgeRealExperiences)
	}
	if m.menti != nil {
		edges = append(edges, user.EdgeMenti)
	}
	if m.mentor != nil {
		edges = append(edges, user.EdgeMentor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRealExperiences:
		ids := make([]ent.Value, 0, len(m.real_experiences))
		for id := range m.real_experiences {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMenti:
		if id := m.menti; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeMentor:
		if id := m.mentor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedreal_experiences != nil {
		edges = append(edges, user.EdgeRealExperiences)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRealExperiences:
		ids := make([]ent.Value, 0, len(m.removedreal_experiences))
		for id := range m.removedreal_experiences {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedreal_experiences {
		edges = append(edges, user.EdgeRealExperiences)
	}
	if m.clearedmenti {
		edges = append(edges, user.EdgeMenti)
	}
	if m.clearedmentor {
		edges = append(edges, user.EdgeMentor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRealExperiences:
		return m.clearedreal_experiences
	case user.EdgeMenti:
		return m.clearedmenti
	case user.EdgeMentor:
		return m.clearedmentor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeMenti:
		m.ClearMenti()
		return nil
	case user.EdgeMentor:
		m.ClearMentor()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRealExperiences:
		m.ResetRealExperiences()
		return nil
	case user.EdgeMenti:
		m.ResetMenti()
		return nil
	case user.EdgeMentor:
		m.ResetMentor()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
